Index: include/VBox/vmm/pdmiceifs.h
===================================================================
--- include/VBox/vmm/pdmiceifs.h	(nicht existent)
+++ include/VBox/vmm/pdmiceifs.h	(Arbeitskopie)
@@ -0,0 +1,149 @@
+/** @file
+ * PDM - Pluggable Device Manager, In-Circuit emulator related interfaces.
+ */
+
+/*
+ * Copyright (C) 2020 Oracle Corporation
+ *
+ * This file is part of VirtualBox Open Source Edition (OSE), as
+ * available from http://www.virtualbox.org. This file is free software;
+ * you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License (GPL) as published by the Free Software
+ * Foundation, in version 2 as it comes in the "COPYING" file of the
+ * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
+ * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
+ *
+ * The contents of this file may alternatively be used under the terms
+ * of the Common Development and Distribution License Version 1.0
+ * (CDDL) only, as it comes in the "COPYING.CDDL" file of the
+ * VirtualBox OSE distribution, in which case the provisions of the
+ * CDDL are applicable instead of those of the GPL.
+ *
+ * You may elect to license modified versions of this file under the
+ * terms and conditions of either the GPL or the CDDL or both.
+ */
+
+#ifndef VBOX_INCLUDED_vmm_pdmiceifs_h
+#define VBOX_INCLUDED_vmm_pdmiceifs_h
+#ifndef RT_WITHOUT_PRAGMA_ONCE
+# pragma once
+#endif
+
+#include <VBox/types.h>
+
+RT_C_DECLS_BEGIN
+
+/** @defgroup grp_pdm_ifs_ice       PDM In-Circuit emulator Interfaces
+ * @ingroup grp_pdm_interfaces
+ * @{
+ */
+
+
+/**
+ * The memory type.
+ */
+typedef enum PDMIICEMEMTYPE
+{
+    /** Invalid memory type. */
+    PDMIICEMEMTYPE_INVALID = 0,
+    /** RAM type. */
+    PDMIICEMEMTYPE_RAM,
+    /** MMIO type. */
+    PDMIICEMEMTYPE_MMIO,
+    /** Unknown memory type, some guesses have to be made which might fail. */
+    PDMIICEMEMTYPE_UNKNONWN,
+    /** 32bit hack. */
+    PDMIICEMEMTYPE_32BIT_HACK = 0x7fffffff
+} PDMIICEMEMTYPE;
+
+
+/** Pointer to an ICE interface. */
+typedef struct PDMIICE *PPDMIICE;
+/**
+ * ICE interface (down).
+ */
+typedef struct PDMIICE
+{
+    /**
+     * Reads from the given I/O port.
+     *
+     * @returns VBox status code.
+     * @param   pInterface          Pointer to the interface structure containing the called function pointer.
+     * @param   IoPort              The I/O port to read from.
+     * @param   cb                  Access width in bytes.
+     * @param   pu32                Where to store the read data.
+     */
+    DECLR3CALLBACKMEMBER(int, pfnIoPortRead, (PPDMIICE pInterface, RTIOPORT IoPort, size_t cb, uint32_t *pu32));
+
+
+    /**
+     * Writes to the given I/O port.
+     *
+     * @returns VBox status code.
+     * @param   pInterface          Pointer to the interface structure containing the called function pointer.
+     * @param   IoPort              The I/O port to write to.
+     * @param   cb                  Access width in bytes.
+     * @param   u32                 The data to write.
+     */
+    DECLR3CALLBACKMEMBER(int, pfnIoPortWrite, (PPDMIICE pInterface, RTIOPORT IoPort, size_t cb, uint32_t u32));
+
+
+    /**
+     * Reads the given amount of memory starting from the given guest physical address.
+     *
+     * @returns VBox status code.
+     * @param   pInterface          Pointer to the interface structure containing the called function pointer.
+     * @param   GCPhysStart         The guest physical address to start reading from.
+     * @param   enmMemType          The accessed memory type.
+     * @param   cbRead              Number of bytes to read.
+     * @param   pvBuf               Where to store the read data.
+     */
+    DECLR3CALLBACKMEMBER(int, pfnMemRead, (PPDMIICE pInterface, RTGCPHYS GCPhysStart, PDMIICEMEMTYPE enmMemType,
+                                           size_t cbRead, void *pvBuf));
+
+
+    /**
+     * Writes the given amount of memory starting from the given guest physical address.
+     *
+     * @returns VBox status code.
+     * @param   pInterface          Pointer to the interface structure containing the called function pointer.
+     * @param   GCPhysStart         The guest physical address to start writing to.
+     * @param   enmMemType          The accessed memory type.
+     * @param   cbWrite             Number of bytes to write.
+     * @param   pvBuf               The data to write.
+     */
+    DECLR3CALLBACKMEMBER(int, pfnMemWrite, (PPDMIICE pInterface, RTGCPHYS GCPhysStart, PDMIICEMEMTYPE enmMemType,
+                                            size_t cbWrite, const void *pvBuf));
+
+
+    /**
+     * Reads the given MSR.
+     *
+     * @returns VBox status code.
+     * @param   pInterface          Pointer to the interface structure containing the called function pointer.
+     * @param   idMsr               The MSR to read.
+     * @param   pu64Val             Where to store the read value upon success.
+     */
+    DECLR3CALLBACKMEMBER(int, pfnMsrRead, (PPDMIICE pInterface, uint32_t idMsr, uint64_t *pu64Val));
+
+
+    /**
+     * Writes the given MSR.
+     *
+     * @returns VBox status code.
+     * @param   pInterface          Pointer to the interface structure containing the called function pointer.
+     * @param   idMsr               The MSR to write.
+     * @param   u64Val              The value to write.
+     */
+    DECLR3CALLBACKMEMBER(int, pfnMsrWrite, (PPDMIICE pInterface, uint32_t idMsr, uint64_t u64Val));
+
+} PDMIICE;
+/** PDMIICE interface ID. */
+#define PDMIICE_IID                       "13abdd9a-f039-41dc-a720-48276083e4df"
+
+
+/** @} */
+
+RT_C_DECLS_END
+
+#endif /* !VBOX_INCLUDED_vmm_pdmiceifs_h */

Property changes on: include/VBox/vmm/pdmiceifs.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Added: svn:keywords
## -0,0 +1 ##
+Author Date Id Revision
\ No newline at end of property
Added: svn:sync-process
## -0,0 +1 ##
+export
\ No newline at end of property
Index: include/VBox/vmm/cpum.h
===================================================================
--- include/VBox/vmm/cpum.h	(Revision 139592)
+++ include/VBox/vmm/cpum.h	(Arbeitskopie)
@@ -2647,6 +2647,39 @@
 
 VMMR3DECL(int)              CPUMR3MsrRangesInsert(PVM pVM, PCCPUMMSRRANGE pNewRange);
 
+/**
+ * CPUM MSR read handler.
+ *
+ * @returns VBox status code.
+ * @retval VINF_CPUM_MSR_READ_DO_DEFAULT when the internal MSR read handler should be called.
+ *
+ * @param   pVM                 Pointer to the cross context VM structure.
+ * @param   idMsr               The MSR to read.
+ * @param   pu64Val             Where to store the value on return.
+ * @param   pvUser              Opaque user data passed during registration.
+ */
+typedef DECLCALLBACKTYPE(VBOXSTRICTRC, FNCPUMMSRREAD,(PVM pVM, uint32_t idMsr, uint64_t *pu64Val, void *pvUser));
+/** Pointer to a FNCPUMMSRREAD. */
+typedef FNCPUMMSRREAD *PFNCPUMMSRREAD;
+
+/**
+ * CPUM MSR write handler.
+ *
+ * @returns VBox status code.
+ * @retval VINF_CPUM_MSR_WRITE_DO_DEFAULT when the internal MSR write handler should be called.
+ *
+ * @param   pVM                 Pointer to the cross context VM structure.
+ * @param   idMsr               The MSR to write.
+ * @param   u64Val              The value to write.
+ * @param   pvUser              Opaque user data passed during registration.
+ */
+typedef DECLCALLBACKTYPE(VBOXSTRICTRC, FNCPUMMSRWRITE,(PVM pVM, uint32_t idMsr, uint64_t u64Val, void *pvUser));
+/** Pointer to a FNCPUMMSRWRITE. */
+typedef FNCPUMMSRWRITE *PFNCPUMMSRWRITE;
+
+VMMR3DECL(int)              CPUMR3MsrRwInterceptSet(PVM pVM, PFNCPUMMSRREAD pfnMsrRead, PFNCPUMMSRWRITE pfnMsrWrite,
+                                                    void *pvUser);
+
 /** @} */
 #endif /* IN_RING3 */
 
Index: src/VBox/Devices/Misc/DevIce.cpp
===================================================================
--- src/VBox/Devices/Misc/DevIce.cpp	(nicht existent)
+++ src/VBox/Devices/Misc/DevIce.cpp	(Arbeitskopie)
@@ -0,0 +1,609 @@
+/* $Id$ */
+/** @file
+ * ICE - In-Circuit Emulator device for hypervisor assisted x86 firmware development
+ */
+
+/*
+ * Copyright (C) 2020 Oracle Corporation
+ *
+ * This file is part of VirtualBox Open Source Edition (OSE), as
+ * available from http://www.virtualbox.org. This file is free software;
+ * you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License (GPL) as published by the Free Software
+ * Foundation, in version 2 as it comes in the "COPYING" file of the
+ * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
+ * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
+ */
+
+
+/*********************************************************************************************************************************
+*   Header Files                                                                                                                 *
+*********************************************************************************************************************************/
+#define LOG_GROUP LOG_GROUP_DEV // LOG_GROUP_DEV_ICE
+#include <VBox/vmm/pdmdev.h>
+#include <VBox/vmm/pdmifs.h>
+#include <VBox/vmm/pdmiceifs.h>
+#include <VBox/vmm/cpum.h>
+#include <VBox/log.h>
+#include <iprt/assert.h>
+#include <iprt/file.h>
+#include <iprt/list.h>
+#include <iprt/mem.h>
+#include <iprt/path.h>
+#include <iprt/uuid.h>
+#include <iprt/x86.h>
+
+#include "VBoxDD.h"
+
+
+/*********************************************************************************************************************************
+*   Defined Constants And Macros                                                                                                 *
+*********************************************************************************************************************************/
+
+/** Maximum number of ports in one I/O port mapping. */
+#define ICE_IO_PORT_MAPPING_MAX _4K
+
+
+/*********************************************************************************************************************************
+*   Structures and Typedefs                                                                                                      *
+*********************************************************************************************************************************/
+
+/** Pointer to the device instance data. */
+typedef struct ICE *PICE;
+
+
+/**
+ * I/O port mapping range.
+ */
+typedef struct ICEIOPORTMAPPING
+{
+    /** The first I/O port mapped. */
+    RTIOPORT                        IoPortBase;
+    /** Number of I/O ports mapped. */
+    RTIOPORT                        cIoPorts;
+    /** The I/O port handle. */
+    IOMIOPORTHANDLE                 hIoPorts;
+} ICEIOPORTMAPPING;
+/** Pointer to an ICE I/O port mapping. */
+typedef ICEIOPORTMAPPING *PICEIOPORTMAPPING;
+
+
+/**
+ * MMIO mapping.
+ */
+typedef struct ICEMMIOMAPPING
+{
+    /** Node for list of mappings. */
+    RTLISTNODE                      NdMmio;
+    /** Guest physical address of the region. */
+    RTGCPHYS                        GCPhysStart;
+    /** Size of the region. */
+    size_t                          cbRegion;
+    /** MMIO region handle. */
+    IOMMMIOHANDLE                   hMmio;
+    /** Mapping description, free with RTStrFree(). */
+    char                            *pszDesc;
+} ICEMMIOMAPPING;
+/** Pointer to an MMIO mapping descriptor. */
+typedef ICEMMIOMAPPING *PICEMMIOMAPPING;
+
+
+/**
+ * ICE device instance data.
+ */
+typedef struct ICE
+{
+    /** Pointer to the NVMe device instance. */
+    PPDMDEVINS                      pDevIns;
+
+    /** The system ROM data. */
+    uint8_t const                   *pu8Rom;
+    /** The system ROM data pointer to be passed to RTFileReadAllFree. */
+    uint8_t                         *pu8RomFree;
+    /** The size of the system ROM. */
+    size_t                          cbRom;
+    /** Where the ROM is initially loaded. */
+    RTGCPHYS                        GCPhysRom;
+    /** Head of list of MMIO mappings. */
+    RTLISTANCHOR                    LstMmio;
+
+    /** I/O port mappings. */
+    ICEIOPORTMAPPING                aIoPorts[65536 / ICE_IO_PORT_MAPPING_MAX]; /* IOM allows mapping 8K ports in one go (sanity checks). */
+    /** The lower ICE driver interface. */
+    PPDMIICE                        pIfsIce;
+
+    /** @name ICE related interface (R3 only stuff).
+     * @{ */
+    /** Pointer to the attached driver's base interface. */
+    R3PTRTYPE(PPDMIBASE)            pDrvBase;
+    /** Pointer to the attached driver's ICE interface. */
+    R3PTRTYPE(PPDMIICE)             pDrvIce;
+
+    /** The base interface. */
+    PDMIBASE                        IBase;
+    /** @} */
+} ICE;
+/** Pointer to const device instance data. */
+typedef const ICE *PCICE;
+
+
+
+static DECLCALLBACK(VBOXSTRICTRC) icePortRead(PPDMDEVINS pDevIns, void *pvUser, RTIOPORT offPort, uint32_t *pu32, unsigned cb)
+{
+    PICE pThis = PDMDEVINS_2_DATA(pDevIns, PICE);
+    PICEIOPORTMAPPING pIoPortMapping = (PICEIOPORTMAPPING)pvUser;
+
+    int rc = VINF_SUCCESS;
+    if (pThis->pDrvIce)
+        rc = pThis->pDrvIce->pfnIoPortRead(pThis->pDrvIce, pIoPortMapping->IoPortBase + offPort, cb, pu32);
+    else
+        *pu32 = UINT32_C(0xffffffff);
+
+    LogFlowFunc(("ICE: I/O port read at %RTiop %zu -> %Rrc (%#x)\n", pIoPortMapping->IoPortBase + offPort, cb, rc, *pu32));
+    return rc;
+}
+
+
+static DECLCALLBACK(VBOXSTRICTRC) icePortWrite(PPDMDEVINS pDevIns, void *pvUser, RTIOPORT offPort, uint32_t u32, unsigned cb)
+{
+    PICE pThis = PDMDEVINS_2_DATA(pDevIns, PICE);
+    PICEIOPORTMAPPING pIoPortMapping = (PICEIOPORTMAPPING)pvUser;
+
+    int rc = VINF_SUCCESS;
+    if (pThis->pDrvIce)
+        rc = pThis->pDrvIce->pfnIoPortWrite(pThis->pDrvIce, pIoPortMapping->IoPortBase + offPort, cb, u32);
+
+    LogFlowFunc(("I/O port write at %RTiop %zu %#x -> %Rrc\n", pIoPortMapping->IoPortBase + offPort, cb, u32, rc));
+    return rc;
+}
+
+
+/**
+ * @callback_method_impl{FNIOMMMIONEWWRITE, ICE MMIO write}
+ */
+static DECLCALLBACK(VBOXSTRICTRC) iceR3MmioMappingWrite(PPDMDEVINS pDevIns, void *pvUser, RTGCPHYS off, void const *pv, unsigned cb)
+{
+    PICE pThis = PDMDEVINS_2_DATA(pDevIns, PICE);
+    PICEMMIOMAPPING pMmio = (PICEMMIOMAPPING)pvUser;
+
+#if 1
+    int rc = VINF_SUCCESS;
+    if (pThis->pDrvIce)
+        rc = pThis->pDrvIce->pfnMemWrite(pThis->pDrvIce, pMmio->GCPhysStart + off, PDMIICEMEMTYPE_MMIO, cb, pv);
+#else
+    RT_NOREF(pThis, pMmio, pvUser, off, pv, cb);
+    int rc = VINF_SUCCESS;
+    AssertReleaseFailed();
+#endif
+
+    return rc;
+}
+
+
+/**
+ * @callback_method_impl{FNIOMMMIONEWREAD, ICE MMIO read}
+ */
+static DECLCALLBACK(VBOXSTRICTRC) iceR3MmioMappingRead(PPDMDEVINS pDevIns, void *pvUser, RTGCPHYS off, void *pv, unsigned cb)
+{
+    PICE pThis = PDMDEVINS_2_DATA(pDevIns, PICE);
+    PICEMMIOMAPPING pMmio = (PICEMMIOMAPPING)pvUser;
+
+#if 1
+    int rc = VINF_SUCCESS;
+    if (pThis->pDrvIce)
+        rc = pThis->pDrvIce->pfnMemRead(pThis->pDrvIce, pMmio->GCPhysStart + off, PDMIICEMEMTYPE_MMIO, cb, pv);
+#else
+    RT_NOREF(pThis, pMmio, pvUser, off, pv, cb);
+    int rc = VINF_SUCCESS;
+    AssertReleaseFailed();
+#endif
+
+    return rc;
+}
+
+
+/**
+ * @callback_method_impl{FNCPUMMSRREAD, ICE MSR read}
+ */
+static DECLCALLBACK(VBOXSTRICTRC) iceR3MsrRead(PVM pVM, uint32_t idMsr, uint64_t *pu64Val, void *pvUser)
+{
+    RT_NOREF(pVM);
+
+    int rc = VINF_CPUM_MSR_READ_DO_DEFAULT;
+    PICE pThis = (PICE)pvUser;
+
+    if (pThis->pDrvIce->pfnMsrRead)
+        rc = pThis->pDrvIce->pfnMsrRead(pThis->pDrvIce, idMsr, pu64Val);
+    if (RT_SUCCESS(rc) && idMsr == MSR_IA32_APICBASE)
+        rc = VINF_CPUM_MSR_READ_DO_DEFAULT;
+    return rc;
+}
+
+
+/**
+ * @callback_method_impl{FNCPUMMSRWRITE, ICE MSR write}
+ */
+static DECLCALLBACK(VBOXSTRICTRC) iceR3MsrWrite(PVM pVM, uint32_t idMsr, uint64_t u64Val, void *pvUser)
+{
+    RT_NOREF(pVM);
+
+    int rc = VINF_CPUM_MSR_WRITE_DO_DEFAULT;
+    PICE pThis = (PICE)pvUser;
+
+    if (pThis->pDrvIce->pfnMsrWrite)
+        rc = pThis->pDrvIce->pfnMsrWrite(pThis->pDrvIce, idMsr, u64Val);
+    if (RT_SUCCESS(rc) && idMsr == MSR_IA32_APICBASE)
+        rc = VINF_CPUM_MSR_WRITE_DO_DEFAULT;
+    return rc;
+
+}
+
+
+/* -=-=-=-=-=-=-=-=- PDMIBASE -=-=-=-=-=-=-=-=- */
+
+/**
+ * @interface_method_impl{PDMIBASE,pfnQueryInterface}
+ */
+static DECLCALLBACK(void *) iceR3QueryInterface(PPDMIBASE pInterface, const char *pszIID)
+{
+    PICE pThis = RT_FROM_MEMBER(pInterface, ICE, IBase);
+    PDMIBASE_RETURN_INTERFACE(pszIID, PDMIBASE, &pThis->IBase);
+    return NULL;
+}
+
+
+/**
+ * @interface_method_impl{PDMDEVREG,pfnMemSetup}
+ */
+static DECLCALLBACK(void) iceR3MemSetup(PPDMDEVINS pDevIns, PDMDEVMEMSETUPCTX enmCtx)
+{
+    RT_NOREF(enmCtx);
+    PICE pThis = PDMDEVINS_2_DATA(pDevIns, PICE);
+    PCPDMDEVHLPR3 pHlp = pDevIns->pHlpR3;
+
+    uint32_t    cPages = RT_ALIGN_64(pThis->cbRom, PAGE_SIZE) >> PAGE_SHIFT;
+    RTGCPHYS    GCPhys = pThis->GCPhysRom;
+    while (cPages > 0)
+    {
+        uint8_t abPage[PAGE_SIZE];
+
+        /* Read the (original) ROM page and write it back to the RAM page. */
+        int rc = PDMDevHlpROMProtectShadow(pDevIns, GCPhys, PAGE_SIZE, PGMROMPROT_READ_ROM_WRITE_RAM);
+        AssertLogRelRC(rc);
+
+        rc = PDMDevHlpPhysRead(pDevIns, GCPhys, abPage, PAGE_SIZE);
+        AssertLogRelRC(rc);
+        if (RT_FAILURE(rc))
+            memset(abPage, 0xcc, sizeof(abPage));
+
+        rc = PDMDevHlpPhysWrite(pDevIns, GCPhys, abPage, PAGE_SIZE);
+        AssertLogRelRC(rc);
+
+        /* Switch to the RAM/RAM mode. */
+        rc = PDMDevHlpROMProtectShadow(pDevIns, GCPhys, PAGE_SIZE, PGMROMPROT_READ_RAM_WRITE_RAM);
+        AssertLogRelRC(rc);
+
+        /* Advance */
+        GCPhys += PAGE_SIZE;
+        cPages--;
+    }
+
+    /* Syncing makes only sense if there is a driver. */
+    if (pThis->pDrvIce)
+    {
+        /*
+         * Check for any RAM ranges we have to sync.
+         */
+        PCFGMNODE pCfgmMemSync = pHlp->pfnCFGMGetChild(pDevIns->pCfg, "MemSync");
+        if (pCfgmMemSync)
+        {
+            int rc = VINF_SUCCESS;
+
+            for (PCFGMNODE pNd = pHlp->pfnCFGMGetFirstChild(pCfgmMemSync); pNd && RT_SUCCESS(rc); pNd = pHlp->pfnCFGMGetNextChild(pNd))
+            {
+                char szName[32];
+                rc = pHlp->pfnCFGMGetName(pNd, &szName[0], sizeof(szName));
+                AssertMsgRCReturnVoid(rc, ("Configuration error: Range name is too long (or something)! rc=%Rrc\n", rc));
+
+                RTGCPHYS GCPhysStart = NIL_RTGCPHYS;
+                rc = pHlp->pfnCFGMQueryU64(pNd, "PhysicalStart", &GCPhysStart);
+                AssertMsgRCReturnVoid(rc, ("Configuration error: Querying \"PhysicalStart\" failed! rc=%Rrc\n", rc));
+
+                uint32_t cbSync = 0;
+                rc = pHlp->pfnCFGMQueryU32(pNd, "Size", &cbSync);
+                AssertMsgRCReturnVoid(rc, ("Configuration error: Querying \"Size\" failed! rc=%Rrc\n", rc));
+
+                LogRel(("ICE: Syncing RAM range %RGp - %RGp (%zu bytes)\n", GCPhysStart, GCPhysStart + cbSync - 1, cbSync));
+
+                while (cbSync)
+                {
+                    uint8_t abSync[_1K];
+                    size_t cbThisSync = RT_MIN(cbSync, sizeof(abSync));
+
+                    rc = pThis->pDrvIce->pfnMemRead(pThis->pDrvIce, GCPhysStart, PDMIICEMEMTYPE_RAM, cbThisSync, &abSync[0]);
+                    AssertMsgRCReturnVoid(rc, ("Reading %zu bytes of memory at %RGp failed! rc=%Rrc\n", cbThisSync, GCPhysStart, rc));
+
+                    PDMDevHlpPhysWrite(pDevIns, GCPhysStart, &abSync[0], cbThisSync);
+                    GCPhysStart += cbThisSync;
+                    cbSync      -= cbThisSync;
+                }
+            }
+        }
+    }
+}
+
+
+/**
+ * @interface_method_impl{PDMDEVREG,pfnDestruct}
+ */
+static DECLCALLBACK(int) iceR3Destruct(PPDMDEVINS pDevIns)
+{
+    PDMDEV_CHECK_VERSIONS_RETURN(pDevIns);
+    PICE pThis = PDMDEVINS_2_DATA(pDevIns, PICE);
+
+    if (pThis->pu8RomFree)
+    {
+        RTFileReadAllFree(pThis->pu8RomFree, pThis->cbRom);
+        pThis->pu8RomFree = NULL;
+    }
+
+    return VINF_SUCCESS;
+}
+
+
+/**
+ * @interface_method_impl{PDMDEVREG,pfnConstruct}
+ */
+static DECLCALLBACK(int) iceR3Construct(PPDMDEVINS pDevIns, int iInstance, PCFGMNODE pCfg)
+{
+    PDMDEV_CHECK_VERSIONS_RETURN(pDevIns);
+    PICE pThis = PDMDEVINS_2_DATA(pDevIns, PICE);
+    PCPDMDEVHLPR3 pHlp = pDevIns->pHlpR3;
+
+    pThis->pDevIns = pDevIns;
+    pThis->IBase.pfnQueryInterface = iceR3QueryInterface;
+
+    RTListInit(&pThis->LstMmio);
+
+    /*
+     * Validate and read the configuration.
+     */
+    PDMDEV_VALIDATE_CONFIG_RETURN(pDevIns,
+                                  "RomImage|"
+                                  "RomLoadAddr|"
+                                  "MapBelow4GB|",
+                                  "MemSync|"
+                                  "MmioRanges");
+
+    char *pszRomImg = NULL;
+    int rc = pHlp->pfnCFGMQueryStringAlloc(pCfg, "RomImage", &pszRomImg);
+    if (RT_SUCCESS(rc))
+    {
+        /* Try setting up the ROM image. */
+        bool fMapBelow4GB;
+        rc = pHlp->pfnCFGMQueryBoolDef(pCfg, "MapBelow4GB", &fMapBelow4GB, true);
+        if (RT_FAILURE(rc))
+            return PDMDEV_SET_ERROR(pDevIns, rc,
+                                    N_("Configuration error: Querying \"MapTop64KBelow4GB\" failed"));
+
+        rc = pHlp->pfnCFGMQueryU64(pCfg, "RomLoadAddr", &pThis->GCPhysRom);
+        if (RT_SUCCESS(rc))
+        {
+            void   *pvFile;
+            size_t  cbFile;
+            rc = RTFileReadAllEx(pszRomImg,
+                                 0 /*off*/,
+                                 RTFOFF_MAX /*cbMax*/,
+                                 RTFILE_RDALL_O_DENY_WRITE,
+                                 &pvFile,
+                                 &cbFile);
+            if (RT_FAILURE(rc))
+                return PDMDevHlpVMSetError(pDevIns, rc, RT_SRC_POS,
+                                           N_("Loading the ROM image '%s' failed with rc=%Rrc"),
+                                           pszRomImg, rc);
+            pThis->pu8RomFree = (uint8_t *)pvFile;
+            pThis->pu8Rom = (uint8_t *)pvFile;
+            pThis->cbRom  = cbFile;
+
+            /* Register the ROM image. */
+            rc = PDMDevHlpROMRegister(pDevIns, pThis->GCPhysRom, pThis->cbRom, pThis->pu8Rom, pThis->cbRom,
+                                      PGMPHYS_ROM_FLAGS_SHADOWED | PGMPHYS_ROM_FLAGS_PERMANENT_BINARY, "ICERomImg");
+            AssertRCReturn(rc, rc);
+
+            rc = PDMDevHlpROMProtectShadow(pDevIns, pThis->GCPhysRom, (uint32_t)pThis->cbRom, PGMROMPROT_READ_RAM_WRITE_RAM);
+            AssertRCReturn(rc, rc);
+
+            if (fMapBelow4GB)
+            {
+                /* We will map the the image just below the 4GB limit where the reset vector will be executed. */
+                rc = PDMDevHlpROMRegister(pDevIns, _4G - pThis->cbRom, pThis->cbRom, pThis->pu8Rom, pThis->cbRom,
+                                          PGMPHYS_ROM_FLAGS_PERMANENT_BINARY, "ICERomImgTop");
+                AssertRCReturn(rc, rc);
+
+                rc = PDMDevHlpROMProtectShadow(pDevIns, _4G - pThis->cbRom, (uint32_t)pThis->cbRom, PGMROMPROT_READ_RAM_WRITE_IGNORE);
+                AssertRCReturn(rc, rc);
+            }
+        }
+        else
+            return PDMDevHlpVMSetError(pDevIns, rc, RT_SRC_POS,
+                                       N_("Configuration error: Querying \"RomLoadAddr\" as a physical guest address failed"));
+
+        MMR3HeapFree(pszRomImg);
+    }
+    else if (rc != VERR_CFGM_VALUE_NOT_FOUND)
+        return PDMDevHlpVMSetError(pDevIns, rc, RT_SRC_POS,
+                                   N_("Configuration error: Querying \"RomImage\" as a string failed"));
+
+
+    for (uint32_t i = 0; i < RT_ELEMENTS(pThis->aIoPorts); i++)
+    {
+        PICEIOPORTMAPPING pIoPortMapping = &pThis->aIoPorts[i];
+
+        pIoPortMapping->IoPortBase = i * ICE_IO_PORT_MAPPING_MAX;
+        pIoPortMapping->cIoPorts   = ICE_IO_PORT_MAPPING_MAX;
+        rc = PDMDevHlpIoPortCreateUAndMap(pDevIns, pIoPortMapping->IoPortBase, pIoPortMapping->cIoPorts,
+                                         icePortWrite, icePortRead, pIoPortMapping,
+                                         "ICE",  NULL /*paExtDescs*/, &pIoPortMapping->hIoPorts);
+        AssertRCReturn(rc, rc);
+    }
+
+    /*
+     * Register MMIO ranges.
+     */
+    PCFGMNODE pCfgmMmio = pHlp->pfnCFGMGetChild(pDevIns->pCfg, "MmioRanges");
+    if (pCfgmMmio)
+    {
+        for (PCFGMNODE pNd = pHlp->pfnCFGMGetFirstChild(pCfgmMmio); pNd && RT_SUCCESS(rc); pNd = pHlp->pfnCFGMGetNextChild(pNd))
+        {
+            char szName[32];
+            rc = pHlp->pfnCFGMGetName(pNd, &szName[0], sizeof(szName));
+            AssertMsgRCReturn(rc, ("Configuration error: Range name is too long (or something)! rc=%Rrc\n", rc), rc);
+
+            RTGCPHYS GCPhysStart = NIL_RTGCPHYS;
+            rc = pHlp->pfnCFGMQueryU64(pNd, "PhysicalStart", &GCPhysStart);
+            AssertMsgRCReturn(rc, ("Configuration error: Querying \"PhysicalStart\" failed! rc=%Rrc\n", rc), rc);
+
+            uint32_t cbMmio = 0;
+            rc = pHlp->pfnCFGMQueryU32(pNd, "Size", &cbMmio);
+            AssertMsgRCReturn(rc, ("Configuration error: Querying \"Size\" failed! rc=%Rrc\n", rc), rc);
+
+            LogRel(("ICE: Creating MMIO range %RGp - %RGp (%zu bytes)\n", GCPhysStart, GCPhysStart + cbMmio - 1, cbMmio));
+
+            PICEMMIOMAPPING pMmioMapping = (PICEMMIOMAPPING)RTMemAllocZ(sizeof(*pMmioMapping));
+            if (pMmioMapping)
+            {
+                pMmioMapping->pszDesc = RTStrDup(&szName[0]);
+                if (pMmioMapping->pszDesc)
+                {
+                    rc = PDMDevHlpMmioCreateEx(pDevIns, cbMmio, IOMMMIO_FLAGS_READ_PASSTHRU | IOMMMIO_FLAGS_WRITE_PASSTHRU,
+                                               NULL /*pPciDev*/,  UINT32_MAX, iceR3MmioMappingWrite, iceR3MmioMappingRead, NULL, pMmioMapping,
+                                               pMmioMapping->pszDesc, &pMmioMapping->hMmio);
+                    AssertRCReturn(rc, rc);
+                    rc = PDMDevHlpMmioMap(pDevIns, pMmioMapping->hMmio, GCPhysStart);
+                    AssertRCReturn(rc, rc);
+
+                    pMmioMapping->GCPhysStart = GCPhysStart;
+                    pMmioMapping->cbRegion    = cbMmio;
+                    RTListAppend(&pThis->LstMmio, &pMmioMapping->NdMmio);
+                }
+                else
+                    AssertLogRelMsgFailedReturn(("Configuration error: Failed to allocate memory for MMIO mapping name!\n"), VERR_NO_MEMORY);
+            }
+            else
+                AssertLogRelMsgFailedReturn(("Configuration error: Failed to allocate memory for MMIO mapping!\n"), VERR_NO_MEMORY);
+        }
+    }
+
+    /*
+     * Attach the ICE driver and get the interfaces.
+     */
+    rc = PDMDevHlpDriverAttach(pDevIns, 0 /*iLUN*/, &pThis->IBase, &pThis->pDrvBase, "ICE");
+    if (RT_SUCCESS(rc))
+    {
+        pThis->pDrvIce = PDMIBASE_QUERY_INTERFACE(pThis->pDrvBase, PDMIICE);
+        if (!pThis->pDrvIce)
+        {
+            AssertLogRelMsgFailed(("Configuration error: instance %d has no ICE interface!\n"));
+            return VERR_PDM_MISSING_INTERFACE;
+        }
+
+        /* Register the MSR intercetps if the driver below exposes the MSR read/write functionality. */
+        if (pThis->pDrvIce->pfnMsrRead || pThis->pDrvIce->pfnMsrWrite)
+        {
+            PVM pVM = PDMDevHlpGetVM(pDevIns);
+            rc = CPUMR3MsrRwInterceptSet(pVM, iceR3MsrRead, iceR3MsrWrite, pThis);
+            AssertMsgRC(rc, ("Configuration error: Setting the MSR read/write intercepts failed! rc=%Rrc\n", rc));
+        }
+    }
+    else if (rc == VERR_PDM_NO_ATTACHED_DRIVER)
+    {
+        pThis->pDrvBase   = NULL;
+        pThis->pDrvIce = NULL;
+        rc = VINF_SUCCESS;
+        LogRel(("ICE#%d: no unit\n", iInstance));
+    }
+    else
+    {
+        AssertLogRelMsgFailed(("ICE: Failed to attach to ICE driver. rc=%Rrc\n", rc));
+        /* Don't call VMSetError here as we assume that the driver already set an appropriate error */
+        return rc;
+    }
+
+
+    return rc;
+}
+
+
+/**
+ * The device registration structure.
+ */
+const PDMDEVREG g_DeviceIce =
+{
+    /* .u32Version = */             PDM_DEVREG_VERSION,
+    /* .uReserved0 = */             0,
+    /* .szName = */                 "ice",
+    /* .fFlags = */                 PDM_DEVREG_FLAGS_DEFAULT_BITS | PDM_DEVREG_FLAGS_NEW_STYLE,
+    /* .fClass = */                 PDM_DEVREG_CLASS_MISC,
+    /* .cMaxInstances = */          1,
+    /* .uSharedVersion = */         42,
+    /* .cbInstanceShared = */       sizeof(ICE),
+    /* .cbInstanceCC = */           0,
+    /* .cbInstanceRC = */           0,
+    /* .cMaxPciDevices = */         0,
+    /* .cMaxMsixVectors = */        0,
+    /* .pszDescription = */         "In-Circuit Emulator for hypervisor assisted x86 firmware debugging",
+#if defined(IN_RING3)
+    /* .pszRCMod = */               "",
+    /* .pszR0Mod = */               "",
+    /* .pfnConstruct = */           iceR3Construct,
+    /* .pfnDestruct = */            iceR3Destruct,
+    /* .pfnRelocate = */            NULL,
+    /* .pfnMemSetup = */            iceR3MemSetup,
+    /* .pfnPowerOn = */             NULL,
+    /* .pfnReset = */               NULL,
+    /* .pfnSuspend = */             NULL,
+    /* .pfnResume = */              NULL,
+    /* .pfnAttach = */              NULL,
+    /* .pfnDetach = */              NULL,
+    /* .pfnQueryInterface = */      NULL,
+    /* .pfnInitComplete = */        NULL,
+    /* .pfnPowerOff = */            NULL,
+    /* .pfnSoftReset = */           NULL,
+    /* .pfnReserved0 = */           NULL,
+    /* .pfnReserved1 = */           NULL,
+    /* .pfnReserved2 = */           NULL,
+    /* .pfnReserved3 = */           NULL,
+    /* .pfnReserved4 = */           NULL,
+    /* .pfnReserved5 = */           NULL,
+    /* .pfnReserved6 = */           NULL,
+    /* .pfnReserved7 = */           NULL,
+#elif defined(IN_RING0)
+    /* .pfnEarlyConstruct = */      NULL,
+    /* .pfnConstruct = */           NULL,
+    /* .pfnDestruct = */            NULL,
+    /* .pfnFinalDestruct = */       NULL,
+    /* .pfnRequest = */             NULL,
+    /* .pfnReserved0 = */           NULL,
+    /* .pfnReserved1 = */           NULL,
+    /* .pfnReserved2 = */           NULL,
+    /* .pfnReserved3 = */           NULL,
+    /* .pfnReserved4 = */           NULL,
+    /* .pfnReserved5 = */           NULL,
+    /* .pfnReserved6 = */           NULL,
+    /* .pfnReserved7 = */           NULL,
+#elif defined(IN_RC)
+    /* .pfnConstruct = */           NULL,
+    /* .pfnReserved0 = */           NULL,
+    /* .pfnReserved1 = */           NULL,
+    /* .pfnReserved2 = */           NULL,
+    /* .pfnReserved3 = */           NULL,
+    /* .pfnReserved4 = */           NULL,
+    /* .pfnReserved5 = */           NULL,
+    /* .pfnReserved6 = */           NULL,
+    /* .pfnReserved7 = */           NULL,
+#else
+# error "Not in IN_RING3, IN_RING0 or IN_RC!"
+#endif
+    /* .u32VersionEnd = */          PDM_DEVREG_VERSION
+};
+

Property changes on: src/VBox/Devices/Misc/DevIce.cpp
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Added: svn:keywords
## -0,0 +1 ##
+Author Date Id Revision
\ No newline at end of property
Added: svn:sync-process
## -0,0 +1 ##
+export
\ No newline at end of property
Index: src/VBox/Devices/Misc/DrvSerialIce.cpp
===================================================================
--- src/VBox/Devices/Misc/DrvSerialIce.cpp	(nicht existent)
+++ src/VBox/Devices/Misc/DrvSerialIce.cpp	(Arbeitskopie)
@@ -0,0 +1,931 @@
+/* $Id$ */
+/** @file
+ * Driver for the ICE device speaking the serialICE (https://serialice.com) protocol.
+ */
+
+/*
+ * Copyright (C) 2020 Oracle Corporation
+ *
+ * This file is part of VirtualBox Open Source Edition (OSE), as
+ * available from http://www.virtualbox.org. This file is free software;
+ * you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License (GPL) as published by the Free Software
+ * Foundation, in version 2 as it comes in the "COPYING" file of the
+ * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
+ * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
+ */
+
+
+/*********************************************************************************************************************************
+*   Header Files                                                                                                                 *
+*********************************************************************************************************************************/
+#define LOG_GROUP LOG_GROUP_DRV_CHAR /** @todo */
+#include <VBox/vmm/pdmdrv.h>
+#include <VBox/vmm/pdmiceifs.h>
+#include <iprt/asm.h>
+#include <iprt/assert.h>
+#include <iprt/poll.h>
+#include <iprt/stream.h>
+#include <iprt/critsect.h>
+#include <iprt/semaphore.h>
+#include <iprt/uuid.h>
+#include <iprt/tcp.h>
+
+#include "VBoxDD.h"
+
+
+/*********************************************************************************************************************************
+*   Defined Constants And Macros                                                                                                 *
+*********************************************************************************************************************************/
+
+
+/*********************************************************************************************************************************
+*   Structures and Typedefs                                                                                                      *
+*********************************************************************************************************************************/
+
+/**
+ * The header for the binary transfer mode.
+ */
+typedef struct SERIALICEBINHDR
+{
+    /** Flags for the transfer. */
+    uint32_t                        fFlags;
+    /** Size of the transfer in bytes. */
+    uint32_t                        cbXfer;
+    /** The start address */
+    uint64_t                        u64AddrStart;
+} SERIALICEBINHDR;
+/** Pointer to a binary transfer header. */
+typedef SERIALICEBINHDR *PSERIALICEBINHDR;
+/** Pointer to a const binary transfer header. */
+typedef const SERIALICEBINHDR *PCSERIALICEBINHDR;
+
+/** Indicates a write request, read if cleared. */
+#define SERIALICE_BIN_REQ_HDR_F_WRITE           RT_BIT(0)
+/** Indicates an I/O port access, memory access if clear. */
+#define SERIALICE_BIN_REQ_HDR_F_IOPORT          RT_BIT(1)
+/** Indicates a a RAM memory access, MMIO or unknown if clear. */
+#define SERIALICE_BIN_REQ_HDR_F_MEM_RAM         RT_BIT(2)
+/** Indicates a a MMIO memory access, RAM or unknown if clear. */
+#define SERIALICE_BIN_REQ_HDR_F_MEM_MMIO        RT_BIT(3)
+
+
+/**
+ * SerialICE driver instance data.
+ *
+ * @implements PDMIICE
+ */
+typedef struct DRVSERIALICE
+{
+    /** Pointer to the driver instance structure. */
+    PPDMDRVINS                  pDrvIns;
+    /** Our ICE interface. */
+    PDMIICE                     IIce;
+
+    /** Where to connect to. */
+    char                        *pszLocation;
+    /** Socket handle of the TCP socket connection. */
+    RTSOCKET                    hTcpSock;
+
+    /** Flag whether the ICE target supports the extended protocol. */
+    bool                        fIceProtExtended;
+
+} DRVSERIALICE;
+/** Pointer to a serialICE driver instance. */
+typedef DRVSERIALICE *PDRVSERIALICE;
+
+
+static const uint8_t s_abHexToChr[16] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };
+
+
+/**
+ * Converts a hex character to the appropriate nibble.
+ *
+ * @returns Nibble of the character.
+ * @param   bVal                    The value to convert.
+ */
+static inline uint8_t drvSerialIceHexToNibble(uint8_t bVal)
+{
+    if (bVal >= '0' && bVal <= '9')
+        return bVal - '0';
+    else if (bVal >= 'a' && bVal <= 'f')
+        return bVal - 'a' + 10;
+    else if (bVal >= 'A' && bVal <= 'F')
+        return bVal - 'A' + 10;
+
+    return 0xff;
+}
+
+
+/**
+ * Parse a ASCII 32bit value hexadecimal value and return the binary representation.
+ *
+ * @returns VBox status code.
+ * @param   pbSrc                   The data to parse.
+ * @param   pu32Val                 Where to return the value on success.
+ */
+static int drvSerialIceParseU32(uint8_t *pbSrc, uint32_t *pu32Val)
+{
+    int rc = VINF_SUCCESS;
+    *pu32Val = 0;
+
+    const uint8_t *pbData = &pbSrc[(sizeof(uint32_t) * 2) - 2];
+    for (uint32_t i = 0; i < sizeof(uint32_t) && RT_SUCCESS(rc); i++)
+    {
+        *pu32Val <<= 8;
+        uint8_t bNbH = drvSerialIceHexToNibble(pbData[0]);
+        uint8_t bNbL = drvSerialIceHexToNibble(pbData[1]);
+        if (bNbH != 0xff && bNbL != 0xff)
+            *pu32Val |= (bNbH << 4) | bNbL;
+        else
+            rc = VERR_NET_PROTOCOL_ERROR;
+    }
+
+    return rc;
+}
+
+
+/**
+ * Parse a ASCII 16bit value hexadecimal value and return the binary representation.
+ *
+ * @returns VBox status code.
+ * @param   pbSrc                   The data to parse.
+ * @param   pu16Val                 Where to return the value on success.
+ */
+static int drvSerialIceParseU16(uint8_t *pbSrc, uint16_t *pu16Val)
+{
+    int rc = VINF_SUCCESS;
+    *pu16Val = 0;
+
+    const uint8_t *pbData = &pbSrc[(sizeof(uint16_t) * 2) - 2];
+    for (uint32_t i = 0; i < sizeof(uint16_t) && RT_SUCCESS(rc); i++)
+    {
+        *pu16Val <<= 8;
+        uint8_t bNbH = drvSerialIceHexToNibble(pbData[0]);
+        uint8_t bNbL = drvSerialIceHexToNibble(pbData[1]);
+        if (bNbH != 0xff && bNbL != 0xff)
+            *pu16Val |= (bNbH << 4) | bNbL;
+        else
+            rc = VERR_NET_PROTOCOL_ERROR;
+    }
+
+    return rc;
+}
+
+
+/**
+ * Parse a ASCII 8bit value hexadecimal value and return the binary representation.
+ *
+ * @returns VBox status code.
+ * @param   pbSrc                   The data to parse.
+ * @param   pu8Val                  Where to return the value on success.
+ */
+static int drvSerialIceParseU8(uint8_t *pbSrc, uint8_t *pu8Val)
+{
+    int rc = VINF_SUCCESS;
+    *pu8Val = 0;
+
+    uint8_t bNbH = drvSerialIceHexToNibble(pbSrc[0]);
+    uint8_t bNbL = drvSerialIceHexToNibble(pbSrc[1]);
+    if (bNbH != 0xff && bNbL != 0xff)
+        *pu8Val |= (bNbH << 4) | bNbL;
+    else
+        rc = VERR_NET_PROTOCOL_ERROR;
+
+    return rc;
+}
+
+
+/**
+ * Encodes a given 32bit binary as a hexadecimal ASCII number.
+ *
+ * @returns nothing.
+ * @param   pbDst                   Where to store the encoded number.
+ * @param   u32Val                  The value to encode.
+ */
+static void drvSerialIceEncodeU32(uint8_t *pbDst, uint32_t u32Val)
+{
+    uint8_t *pbCur = pbDst + sizeof(uint32_t) * 2 - 1;
+
+    for (uint32_t i = 0; i < sizeof(uint32_t); i++)
+    {
+        *pbCur-- = s_abHexToChr[u32Val & 0xf];
+        *pbCur-- = s_abHexToChr[(u32Val >> 4) & 0xf];
+        u32Val >>= 8;
+    }
+}
+
+
+/**
+ * Waits until the serialICE target is ready for a new command.
+ *
+ * @returns VBox status code.
+ * @param   pThis                   The SerialICE driver instance.
+ */
+static int drvSerialIceWaitForCmdReadiness(PDRVSERIALICE pThis)
+{
+    int rc = VINF_SUCCESS;
+
+    /** @todo Inefficient and plain horrible but enough for a proof-of-concept. */
+    for (;;)
+    {
+        uint8_t bRead = 0;
+        rc = RTTcpRead(pThis->hTcpSock, &bRead, sizeof(bRead), NULL /*pcbRead*/);
+        if (RT_SUCCESS(rc))
+        {
+            if (bRead == '>')
+                break;
+        }
+        else
+            return PDMDrvHlpVMSetError(pThis->pDrvIns, rc, RT_SRC_POS,
+                                       N_("DrvSerialIce#%d to read data while waiting for readiness %s"),
+                                       pThis->pDrvIns->iInstance, pThis->pszLocation);
+    }
+
+    return rc;
+}
+
+
+/**
+ * Legacy protocol memory read request handler.
+ *
+ * @returns VBox status code.
+ * @param   pThis                   The SerialICE driver instance.
+ * @param   GCPhysStart             The guest physical address to start reading from.
+ * @param   cbRead                  Number of bytes to read.
+ * @param   pvBuf                   Where to store the read data.
+ */
+static int drvSerialIceMemReadLegacy(PDRVSERIALICE pThis, RTGCPHYS GCPhysStart, size_t cbRead, void *pvBuf)
+{
+    int rc = VINF_SUCCESS;
+    uint8_t *pbCur = (uint8_t *)pvBuf;
+    uint8_t abMemRdCmd[3 + 8 + 2] = { '*', 'r', 'm', 0 };
+    while (   cbRead
+           && RT_SUCCESS(rc))
+    {
+        size_t cbThisRead = RT_MIN(cbRead, sizeof(uint32_t));
+        uint8_t *pbMemRdCmd = &abMemRdCmd[2];
+
+        *pbMemRdCmd++ = s_abHexToChr[(GCPhysStart >> 28) & 0xf];
+        *pbMemRdCmd++ = s_abHexToChr[(GCPhysStart >> 24) & 0xf];
+        *pbMemRdCmd++ = s_abHexToChr[(GCPhysStart >> 20) & 0xf];
+        *pbMemRdCmd++ = s_abHexToChr[(GCPhysStart >> 16) & 0xf];
+        *pbMemRdCmd++ = s_abHexToChr[(GCPhysStart >> 12) & 0xf];
+        *pbMemRdCmd++ = s_abHexToChr[(GCPhysStart >> 8) & 0xf];
+        *pbMemRdCmd++ = s_abHexToChr[(GCPhysStart >> 4) & 0xf];
+        *pbMemRdCmd++ = s_abHexToChr[GCPhysStart & 0xf];
+
+        /* Add the . and the size .*/
+        *pbMemRdCmd++ = '.';
+        switch (cbThisRead)
+        {
+            case 1:
+                *pbMemRdCmd++ = 'b';
+                break;
+            case 2:
+                *pbMemRdCmd++ = 'w';
+                break;
+            case 4:
+                *pbMemRdCmd++ = 'l';
+                break;
+            default:
+                AssertMsgFailed(("Invalid write size %zu\n", cbThisRead));
+        }
+
+        rc = RTTcpWrite(pThis->hTcpSock, &abMemRdCmd[0], pbMemRdCmd - &abMemRdCmd[0]);
+        if (RT_SUCCESS(rc))
+        {
+            /* Wait for the reply. */
+            for (;;)
+            {
+                /* Skipy any spaces and newlines which might still be in the buffer. */
+                uint8_t bRead = 0;
+                rc = RTTcpRead(pThis->hTcpSock, &bRead, sizeof(bRead), NULL /*pcbRead*/);
+                if (RT_SUCCESS(rc))
+                {
+                    if (   bRead == ' '
+                        || bRead == '\n'
+                        || bRead == '\r')
+                        continue;
+                    else
+                    {
+                        /* Read the remaining data, at most 8 bytes for a 32bit value. */
+                        char abRecv[9] = { 0 };
+                        abRecv[0] = bRead;
+
+                        rc = RTTcpRead(pThis->hTcpSock, &abRecv[1], (cbThisRead * 2) - 1, NULL /*pcbRead*/);
+                        if (RT_SUCCESS(rc))
+                        {
+                            //const char *pbData = &abRecv[(cbThisRead * 2) - 2];
+                            for (uint32_t i = 0; i < cbThisRead && RT_SUCCESS(rc); i++)
+                            {
+                                rc = RTStrConvertHexBytes(&abRecv[i*2] /*pbData*/, pbCur, 1, 0 /*fFlags*/);
+                                if (   rc == VWRN_TRAILING_CHARS
+                                    || rc == VERR_BUFFER_OVERFLOW)
+                                    rc = VINF_SUCCESS;
+
+                                //pbData -= 2;
+                                pbCur++;
+                            }
+                        }
+
+                        break;
+                    }
+                }
+                else
+                    break;
+            }
+
+            if (RT_SUCCESS(rc))
+                rc = drvSerialIceWaitForCmdReadiness(pThis);
+        }
+
+        GCPhysStart += cbThisRead;
+        cbRead      -= cbThisRead;
+    }
+
+    return rc;
+}
+
+
+/**
+ * Legacy protocol memory write request handler.
+ *
+ * @returns VBox status code.
+ * @param   pThis                   The SerialICE driver instance.
+ * @param   GCPhysStart             The guest physical address to start writing.
+ * @param   cbWrite                 Number of bytes to write.
+ * @param   pvBuf                   The data to write.
+ */
+static int drvSerialIceMemWriteLegacy(PDRVSERIALICE pThis, RTGCPHYS GCPhysStart, size_t cbWrite, const void *pvBuf)
+{
+    int rc = VINF_SUCCESS;
+    const uint8_t *pbCur = (const uint8_t *)pvBuf;
+    uint8_t abMemWrCmd[3 + 8 + 3 + 8] = { '*', 'w', 'm', 0 };
+
+    while (   cbWrite
+           && RT_SUCCESS(rc))
+    {
+        size_t cbThisWrite = RT_MIN(cbWrite, sizeof(uint32_t));
+        uint8_t *pbMemWrCmd = &abMemWrCmd[2];
+
+        *pbMemWrCmd++ = s_abHexToChr[(GCPhysStart >> 28) & 0xf];
+        *pbMemWrCmd++ = s_abHexToChr[(GCPhysStart >> 24) & 0xf];
+        *pbMemWrCmd++ = s_abHexToChr[(GCPhysStart >> 20) & 0xf];
+        *pbMemWrCmd++ = s_abHexToChr[(GCPhysStart >> 16) & 0xf];
+        *pbMemWrCmd++ = s_abHexToChr[(GCPhysStart >> 12) & 0xf];
+        *pbMemWrCmd++ = s_abHexToChr[(GCPhysStart >> 8) & 0xf];
+        *pbMemWrCmd++ = s_abHexToChr[(GCPhysStart >> 4) & 0xf];
+        *pbMemWrCmd++ = s_abHexToChr[GCPhysStart & 0xf];
+
+        /* Add the . and the size .*/
+        *pbMemWrCmd++ = '.';
+        switch (cbThisWrite)
+        {
+            case 1:
+                *pbMemWrCmd++ = 'b';
+                break;
+            case 2:
+                *pbMemWrCmd++ = 'w';
+                break;
+            case 4:
+                *pbMemWrCmd++ = 'l';
+                break;
+            default:
+                AssertMsgFailed(("Invalid write size %zu\n", cbThisWrite));
+        }
+
+        /* Encode the data to write. */
+        *pbMemWrCmd++ = '=';
+
+        uint8_t *pbData = pbMemWrCmd + (cbThisWrite * 2) - 1;
+        for (uint32_t i = 0; i < cbThisWrite; i++)
+        {
+            *pbData-- = s_abHexToChr[*pbCur & 0xf];
+            *pbData-- = s_abHexToChr[(*pbCur >> 4) & 0xf];
+            pbCur++;
+        }
+
+        rc = RTTcpWrite(pThis->hTcpSock, &abMemWrCmd[0], pbMemWrCmd - &abMemWrCmd[0]);
+        if (RT_SUCCESS(rc))
+            rc = drvSerialIceWaitForCmdReadiness(pThis);
+
+        GCPhysStart += cbThisWrite;
+        cbWrite     -= cbThisWrite;
+    }
+
+    return rc;
+}
+
+
+/* -=-=-=-=- IBase -=-=-=-=- */
+
+/**
+ * @interface_method_impl{PDMIBASE,pfnQueryInterface}
+ */
+static DECLCALLBACK(void *) drvSerialIceQueryInterface(PPDMIBASE pInterface, const char *pszIID)
+{
+    PPDMDRVINS    pDrvIns = PDMIBASE_2_PDMDRV(pInterface);
+    PDRVSERIALICE pThis = PDMINS_2_DATA(pDrvIns, PDRVSERIALICE);
+
+    PDMIBASE_RETURN_INTERFACE(pszIID, PDMIBASE, &pDrvIns->IBase);
+    PDMIBASE_RETURN_INTERFACE(pszIID, PDMIICE, &pThis->IIce);
+    return NULL;
+}
+
+
+/* -=-=-=-=- IIce -=-=-=-=- */
+
+
+/**
+ * @interface_method_impl{PDMIICE,pfnIoPortRead}
+ */
+static DECLCALLBACK(int) drvSerialIceIoPortRead(PPDMIICE pInterface, RTIOPORT IoPort, size_t cb, uint32_t *pu32)
+{
+    LogFlowFunc(("pInterface=%#p\n", pInterface));
+    PDRVSERIALICE pThis = RT_FROM_MEMBER(pInterface, DRVSERIALICE, IIce);
+
+    /* The command looks like *ri<ioport as 4 digit hex>.<b|w|l>, so *ri03f8.b for example */
+    uint8_t abIoRdCmd[9] = { '*', 'r', 'i', 0, 0, 0, 0, '.', 0};
+    abIoRdCmd[3] = s_abHexToChr[(IoPort >> 12) & 0xf];
+    abIoRdCmd[4] = s_abHexToChr[(IoPort >> 8) & 0xf];
+    abIoRdCmd[5] = s_abHexToChr[(IoPort >> 4) & 0xf];
+    abIoRdCmd[6] = s_abHexToChr[IoPort & 0xf];
+
+    size_t cbRecv = 0;
+    if (cb == 1)
+    {
+        abIoRdCmd[8] = 'b';
+        cbRecv = 2;
+    }
+    else if (cb == 2)
+    {
+        abIoRdCmd[8] = 'w';
+        cbRecv = 4;
+    }
+    else if (cb == 4)
+    {
+        abIoRdCmd[8] = 'l';
+        cbRecv = 8;
+    }
+
+    int rc = RTTcpWrite(pThis->hTcpSock, &abIoRdCmd[0], sizeof(abIoRdCmd));
+    if (RT_SUCCESS(rc))
+    {
+        /* Wait for the reply. */
+        for (;;)
+        {
+            /* Skipy any spaces and newlines which might still be in the buffer. */
+            uint8_t bRead = 0;
+            rc = RTTcpRead(pThis->hTcpSock, &bRead, sizeof(bRead), NULL /*pcbRead*/);
+            if (RT_SUCCESS(rc))
+            {
+                if (   bRead == ' '
+                    || bRead == '\n'
+                    || bRead == '\r')
+                    continue;
+                else
+                {
+                    /* Read the remaining data, at most 8 bytes for 32bit value. */
+                    uint8_t abRecv[9] = { 0 };
+                    abRecv[0] = bRead;
+                    cbRecv--;
+
+                    rc = RTTcpRead(pThis->hTcpSock, &abRecv[1], cbRecv, NULL /*pcbRead*/);
+                    if (RT_SUCCESS(rc))
+                    {
+                        switch (cb)
+                        {
+                            case 1:
+                            {
+                                uint8_t bVal = 0;
+                                rc = drvSerialIceParseU8(&abRecv[0], &bVal);
+                                *pu32 = bVal;
+                                break;
+                            }
+                            case 2:
+                            {
+                                uint16_t u16Val = 0;
+                                rc = drvSerialIceParseU16(&abRecv[0], &u16Val);
+                                *pu32 = u16Val;
+                                break;
+                            }
+                            case 4:
+                            {
+                                uint32_t u32Val = 0;
+                                rc = drvSerialIceParseU32(&abRecv[0], &u32Val);
+                                *pu32 = u32Val;
+                                break;
+                            }
+                            default:
+                                AssertMsgFailed(("Invalid size value %zu!\n", cb));
+                                break;
+                        }
+
+                        int rc2 = drvSerialIceWaitForCmdReadiness(pThis);
+                        if (   RT_SUCCESS(rc)
+                            && RT_FAILURE(rc2))
+                            rc = rc2;
+                    }
+
+                    break;
+                }
+            }
+            else
+                break;
+        }
+    }
+
+    return rc;
+}
+
+
+/**
+ * @interface_method_impl{PDMIICE,pfnIoPortWrite}
+ */
+static DECLCALLBACK(int) drvSerialIceIoPortWrite(PPDMIICE pInterface, RTIOPORT IoPort, size_t cb, uint32_t u32)
+{
+    LogFlowFunc(("pInterface=%#p\n", pInterface));
+    PDRVSERIALICE pThis = RT_FROM_MEMBER(pInterface, DRVSERIALICE, IIce);
+
+    /* The command looks like *wi<ioport as 4 digit hex>.<b|w|l>=<data>, so *wi03f8.b=01 for example */
+    uint8_t abIoWrCmd[] = { '*', 'w', 'i', 0, 0, 0, 0, '.', 0, '=', 0, 0, 0, 0, 0, 0, 0, 0 };
+    abIoWrCmd[3] = s_abHexToChr[(IoPort >> 12) & 0xf];
+    abIoWrCmd[4] = s_abHexToChr[(IoPort >> 8) & 0xf];
+    abIoWrCmd[5] = s_abHexToChr[(IoPort >> 4) & 0xf];
+    abIoWrCmd[6] = s_abHexToChr[IoPort & 0xf];
+
+    size_t cbData = 0;
+    size_t cbSend = 10;
+    if (cb == 1)
+    {
+        abIoWrCmd[8] = 'b';
+        cbData = 2;
+    }
+    else if (cb == 2)
+    {
+        abIoWrCmd[8] = 'w';
+        cbData = 4;
+    }
+    else if (cb == 4)
+    {
+        abIoWrCmd[8] = 'l';
+        cbData = 8;
+    }
+
+    uint8_t *pbData = &abIoWrCmd[RT_ELEMENTS(abIoWrCmd) - (8 - cbData) - 1];
+    for (uint32_t i = 0; i < cbData; i++)
+    {
+        *pbData-- = s_abHexToChr[u32 & 0xf];
+        u32 >>= 4;
+    }
+
+    int rc = RTTcpWrite(pThis->hTcpSock, &abIoWrCmd[0], cbSend + cbData);
+    if (RT_SUCCESS(rc))
+        rc = drvSerialIceWaitForCmdReadiness(pThis);
+
+    return rc;
+
+}
+
+
+/**
+ * @interface_method_impl{PDMIICE,pfnMemRead}
+ */
+static DECLCALLBACK(int) drvSerialIceMemRead(PPDMIICE pInterface, RTGCPHYS GCPhysStart, PDMIICEMEMTYPE enmMemType,
+                                             size_t cbRead, void *pvBuf)
+{
+    LogFlowFunc(("pInterface=%#p\n", pInterface));
+    PDRVSERIALICE pThis = RT_FROM_MEMBER(pInterface, DRVSERIALICE, IIce);
+
+    if (!pThis->fIceProtExtended)
+        return drvSerialIceMemReadLegacy(pThis, GCPhysStart, cbRead, pvBuf);
+
+    int rc = VINF_SUCCESS;
+    SERIALICEBINHDR ReqHdr;
+
+    ReqHdr.fFlags       = 0;
+    ReqHdr.cbXfer       = (uint32_t)cbRead;
+    ReqHdr.u64AddrStart = GCPhysStart;
+    if (enmMemType == PDMIICEMEMTYPE_RAM)
+        ReqHdr.fFlags |= SERIALICE_BIN_REQ_HDR_F_MEM_RAM;
+    else if (enmMemType == PDMIICEMEMTYPE_MMIO)
+        ReqHdr.fFlags |= SERIALICE_BIN_REQ_HDR_F_MEM_MMIO;
+
+    uint8_t bBinReq = '!';
+    rc = RTTcpWrite(pThis->hTcpSock, &bBinReq, sizeof(bBinReq));
+    if (RT_SUCCESS(rc))
+        rc = RTTcpWrite(pThis->hTcpSock, &ReqHdr, sizeof(ReqHdr));
+    if (RT_SUCCESS(rc))
+        rc = RTTcpRead(pThis->hTcpSock, pvBuf, cbRead, NULL /*pcbRead*/);
+    if (RT_SUCCESS(rc))
+        rc = drvSerialIceWaitForCmdReadiness(pThis);
+
+    return rc;
+}
+
+
+/**
+ * @interface_method_impl{PDMIICE,pfnMemWrite}
+ */
+static DECLCALLBACK(int) drvSerialIceMemWrite(PPDMIICE pInterface, RTGCPHYS GCPhysStart, PDMIICEMEMTYPE enmMemType,
+                                              size_t cbWrite, const void *pvBuf)
+{
+    LogFlowFunc(("pInterface=%#p\n", pInterface));
+    PDRVSERIALICE pThis = RT_FROM_MEMBER(pInterface, DRVSERIALICE, IIce);
+
+    if (!pThis->fIceProtExtended)
+        return drvSerialIceMemWriteLegacy(pThis, GCPhysStart, cbWrite, pvBuf);
+
+    int rc = VINF_SUCCESS;
+    SERIALICEBINHDR ReqHdr;
+
+    ReqHdr.fFlags       = SERIALICE_BIN_REQ_HDR_F_WRITE;
+    ReqHdr.cbXfer       = (uint32_t)cbWrite;
+    ReqHdr.u64AddrStart = GCPhysStart;
+    if (enmMemType == PDMIICEMEMTYPE_RAM)
+        ReqHdr.fFlags |= SERIALICE_BIN_REQ_HDR_F_MEM_RAM;
+    else if (enmMemType == PDMIICEMEMTYPE_MMIO)
+        ReqHdr.fFlags |= SERIALICE_BIN_REQ_HDR_F_MEM_MMIO;
+
+    uint8_t bBinReq = '!';
+    rc = RTTcpWrite(pThis->hTcpSock, &bBinReq, sizeof(bBinReq));
+    if (RT_SUCCESS(rc))
+        rc = RTTcpWrite(pThis->hTcpSock, &ReqHdr, sizeof(ReqHdr));
+    if (RT_SUCCESS(rc))
+        rc = RTTcpWrite(pThis->hTcpSock, pvBuf, cbWrite);
+    if (RT_SUCCESS(rc))
+        rc = drvSerialIceWaitForCmdReadiness(pThis);
+
+    return rc;
+}
+
+
+static DECLCALLBACK(int) drvSerialIceMsrRead(PPDMIICE pInterface, uint32_t idMsr, uint64_t *pu64Val)
+{
+    LogFlowFunc(("pInterface=%#p\n", pInterface));
+    PDRVSERIALICE pThis = RT_FROM_MEMBER(pInterface, DRVSERIALICE, IIce);
+
+    /* The command looks like *rc<idMsr>.<idKey>, so *rqc0000001b.9c5a203a for example */
+    uint8_t abMsrRdCmd[] = { '*', 'r', 'c', 0, 0, 0, 0, 0, 0, 0, 0, '.', 0, 0, 0, 0, 0, 0, 0, 0 };
+
+    drvSerialIceEncodeU32(&abMsrRdCmd[3], idMsr);
+    drvSerialIceEncodeU32(&abMsrRdCmd[12], 0x9c5a203a);
+
+    int rc = RTTcpWrite(pThis->hTcpSock, &abMsrRdCmd[0], sizeof(abMsrRdCmd));
+    if (RT_SUCCESS(rc))
+    {
+        /* Wait for the reply. */
+        for (;;)
+        {
+            /* Skipy any spaces and newlines which might still be in the buffer. */
+            uint8_t bRead = 0;
+            rc = RTTcpRead(pThis->hTcpSock, &bRead, sizeof(bRead), NULL /*pcbRead*/);
+            if (RT_SUCCESS(rc))
+            {
+                if (   bRead == ' '
+                    || bRead == '\n'
+                    || bRead == '\r')
+                    continue;
+                else
+                {
+                    /* Read the remaining data, exactly 17 bytes. */
+                    uint8_t abRecv[17] = { 0 };
+                    abRecv[0] = bRead;
+
+                    rc = RTTcpRead(pThis->hTcpSock, &abRecv[1], sizeof(abRecv) - 1, NULL /*pcbRead*/);
+                    if (RT_SUCCESS(rc))
+                    {
+                        if (abRecv[8] == '.') /* High and low part are separated by a dot */
+                        {
+                            uint32_t u32ValHigh = 0;
+                            uint32_t u32ValLow = 0;
+                            rc = drvSerialIceParseU32(&abRecv[0], &u32ValHigh);
+                            if (RT_SUCCESS(rc))
+                                rc = drvSerialIceParseU32(&abRecv[9], &u32ValLow);
+                            if (RT_SUCCESS(rc))
+                                *pu64Val = ((uint64_t)u32ValHigh) << 32 | u32ValLow;
+                        }
+                        else
+                            rc = VERR_NET_PROTOCOL_ERROR;
+
+                        if (RT_SUCCESS(rc))
+                            rc = drvSerialIceWaitForCmdReadiness(pThis);
+                    }
+
+                    break;
+                }
+            }
+            else
+                break;
+        }
+    }
+
+    return rc;
+}
+
+
+static DECLCALLBACK(int) drvSerialIceMsrWrite(PPDMIICE pInterface, uint32_t idMsr, uint64_t u64Val)
+{
+    LogFlowFunc(("pInterface=%#p\n", pInterface));
+    PDRVSERIALICE pThis = RT_FROM_MEMBER(pInterface, DRVSERIALICE, IIce);
+
+    /* The command looks like *wc<idMsr>.<idKey>=<edx>.<eax>, so *wc0000001b.9c5a203a=00000000.fee00100 for example */
+    uint8_t abMsrWrCmd[] = { '*', 'w', 'c', 0, 0, 0, 0, 0, 0, 0, 0, '.', 0, 0, 0, 0, 0, 0, 0, 0, '=', 0, 0, 0, 0, 0, 0, 0, 0, '.', 0, 0, 0, 0, 0, 0, 0, 0 };
+
+    drvSerialIceEncodeU32(&abMsrWrCmd[3], idMsr);
+    drvSerialIceEncodeU32(&abMsrWrCmd[12], 0x9c5a203a);
+
+    /* The value split into two 32bit values. */
+    drvSerialIceEncodeU32(&abMsrWrCmd[21], (uint32_t)(u64Val >> 32));
+    drvSerialIceEncodeU32(&abMsrWrCmd[30], (uint32_t)u64Val);
+
+    int rc = RTTcpWrite(pThis->hTcpSock, &abMsrWrCmd[0], sizeof(abMsrWrCmd));
+    if (RT_SUCCESS(rc))
+        rc = drvSerialIceWaitForCmdReadiness(pThis);
+
+    return rc;
+}
+
+
+/**
+ * Destruct a TCP socket stream driver instance.
+ *
+ * Most VM resources are freed by the VM. This callback is provided so that
+ * any non-VM resources can be freed correctly.
+ *
+ * @param   pDrvIns     The driver instance data.
+ */
+static DECLCALLBACK(void) drvSerialIceDestruct(PPDMDRVINS pDrvIns)
+{
+    PDRVSERIALICE pThis = PDMINS_2_DATA(pDrvIns, PDRVSERIALICE);
+    LogFlow(("%s: %s\n", __FUNCTION__, pThis->pszLocation));
+    PDMDRV_CHECK_VERSIONS_RETURN_VOID(pDrvIns);
+
+    if (pThis->hTcpSock != NIL_RTSOCKET)
+    {
+        int rc = RTSocketShutdown(pThis->hTcpSock, true /* fRead */, true /* fWrite */);
+        AssertRC(rc);
+
+        rc = RTSocketClose(pThis->hTcpSock);
+        AssertRC(rc); RT_NOREF(rc);
+
+        pThis->hTcpSock = NIL_RTSOCKET;
+    }
+
+    MMR3HeapFree(pThis->pszLocation);
+    pThis->pszLocation = NULL;
+}
+
+
+/**
+ * Construct a SerialICE driver instance.
+ *
+ * @copydoc FNPDMDRVCONSTRUCT
+ */
+static DECLCALLBACK(int) drvSerialIceConstruct(PPDMDRVINS pDrvIns, PCFGMNODE pCfg, uint32_t fFlags)
+{
+    RT_NOREF(pCfg, fFlags);
+    PDMDRV_CHECK_VERSIONS_RETURN(pDrvIns);
+    PDRVSERIALICE pThis = PDMINS_2_DATA(pDrvIns, PDRVSERIALICE);
+    LogFlow(("%s: iInstance=%d\n", __FUNCTION__, pDrvIns->iInstance));
+
+    /*
+     * Init basic data members and interfaces.
+     */
+    pThis->pDrvIns                               = pDrvIns;
+    pThis->fIceProtExtended                      = false;
+    /* IBase. */
+    pDrvIns->IBase.pfnQueryInterface             = drvSerialIceQueryInterface;
+    /* IIce. */
+    pThis->IIce.pfnIoPortRead                    = drvSerialIceIoPortRead;
+    pThis->IIce.pfnIoPortWrite                   = drvSerialIceIoPortWrite;
+    pThis->IIce.pfnMemRead                       = drvSerialIceMemRead;
+    pThis->IIce.pfnMemWrite                      = drvSerialIceMemWrite;
+    pThis->IIce.pfnMsrRead                       = drvSerialIceMsrRead;
+    pThis->IIce.pfnMsrWrite                      = drvSerialIceMsrWrite;
+
+    /*
+     * Validate and read the configuration.
+     */
+    PDMDRV_VALIDATE_CONFIG_RETURN(pDrvIns, "Location", "");
+
+    int rc = CFGMR3QueryStringAlloc(pCfg, "Location", &pThis->pszLocation);
+    if (RT_FAILURE(rc))
+        return PDMDrvHlpVMSetError(pDrvIns, rc, RT_SRC_POS,
+                                   N_("Configuration error: querying \"Location\" resulted in %Rrc"), rc);
+
+    char *pszPort = strchr(pThis->pszLocation, ':');
+    if (!pszPort)
+        return PDMDrvHlpVMSetError(pDrvIns, VERR_NOT_FOUND, RT_SRC_POS,
+                                   N_("DrvSerialIce#%d: The location misses the port to connect to"),
+                                   pDrvIns->iInstance);
+
+    *pszPort = '\0'; /* Overwrite temporarily to avoid copying the hostname into a temporary buffer. */
+    uint32_t uPort = 0;
+    rc = RTStrToUInt32Ex(pszPort + 1, NULL, 10, &uPort);
+    if (RT_FAILURE(rc))
+        return PDMDrvHlpVMSetError(pDrvIns, rc, RT_SRC_POS,
+                                   N_("DrvSerialIce#%d: The port part of the location is not a numerical value"),
+                                   pDrvIns->iInstance);
+
+    rc = RTTcpClientConnect(pThis->pszLocation, uPort, &pThis->hTcpSock);
+    *pszPort = ':'; /* Restore delimiter before checking the status. */
+    if (RT_FAILURE(rc))
+        return PDMDrvHlpVMSetError(pDrvIns, rc, RT_SRC_POS,
+                                   N_("DrvSerialIce#%d failed to connect to socket %s"),
+                                   pDrvIns->iInstance, pThis->pszLocation);
+
+    RTTcpSetSendCoalescing(pThis->hTcpSock, false);
+
+    /* Read the version string and wait for the > indicating readiness for receiving commands. */
+    rc = drvSerialIceWaitForCmdReadiness(pThis);
+    if (RT_SUCCESS(rc))
+    {
+        /* Check whether the target supports the extended protocol. */
+        uint8_t bQueryExtended = '?';
+
+        rc = RTTcpWrite(pThis->hTcpSock, &bQueryExtended, sizeof(bQueryExtended));
+        if (RT_SUCCESS(rc))
+        {
+            for (;;)
+            {
+                /* Skipy any spaces and newlines which might still be in the buffer. */
+                uint8_t bRead = 0;
+                rc = RTTcpRead(pThis->hTcpSock, &bRead, sizeof(bRead), NULL /*pcbRead*/);
+                if (RT_SUCCESS(rc))
+                {
+                    if (   bRead == ' '
+                        || bRead == '\n'
+                        || bRead == '\r')
+                        continue;
+                    else if (bRead == '1')
+                    {
+                        pThis->fIceProtExtended = true;
+                        rc = drvSerialIceWaitForCmdReadiness(pThis);
+                    }
+                    else if (bRead != '>')
+                        rc = drvSerialIceWaitForCmdReadiness(pThis);
+
+                    break;
+                }
+                else
+                    break;
+            }
+        }
+    }
+
+    return rc;
+}
+
+
+/**
+ * SerialICE driver registration record.
+ */
+const PDMDRVREG g_DrvSerialIce =
+{
+    /* u32Version */
+    PDM_DRVREG_VERSION,
+    /* szName */
+    "serial-ice",
+    /* szRCMod */
+    "",
+    /* szR0Mod */
+    "",
+    /* pszDescription */
+    "SerialICE driver.",
+    /* fFlags */
+    PDM_DRVREG_FLAGS_HOST_BITS_DEFAULT,
+    /* fClass. */
+    PDM_DRVREG_CLASS_CHAR,
+    /* cMaxInstances */
+    ~0U,
+    /* cbInstance */
+    sizeof(DRVSERIALICE),
+    /* pfnConstruct */
+    drvSerialIceConstruct,
+    /* pfnDestruct */
+    drvSerialIceDestruct,
+    /* pfnRelocate */
+    NULL,
+    /* pfnIOCtl */
+    NULL,
+    /* pfnPowerOn */
+    NULL,
+    /* pfnReset */
+    NULL,
+    /* pfnSuspend */
+    NULL,
+    /* pfnResume */
+    NULL,
+    /* pfnAttach */
+    NULL,
+    /* pfnDetach */
+    NULL,
+    /* pfnPowerOff */
+    NULL,
+    /* pfnSoftReset */
+    NULL,
+    /* u32EndVersion */
+    PDM_DRVREG_VERSION
+};

Property changes on: src/VBox/Devices/Misc/DrvSerialIce.cpp
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Added: svn:keywords
## -0,0 +1 ##
+Author Date Id Revision
\ No newline at end of property
Added: svn:sync-process
## -0,0 +1 ##
+export
\ No newline at end of property
Index: src/VBox/Devices/build/VBoxDD.cpp
===================================================================
--- src/VBox/Devices/build/VBoxDD.cpp	(Revision 139592)
+++ src/VBox/Devices/build/VBoxDD.cpp	(Arbeitskopie)
@@ -220,6 +220,9 @@
     if (RT_FAILURE(rc))
         return rc;
 #endif
+    rc = pCallbacks->pfnRegister(pCallbacks, &g_DeviceIce);
+    if (RT_FAILURE(rc))
+        return rc;
 
     return VINF_SUCCESS;
 }
@@ -392,6 +395,9 @@
     rc = pCallbacks->pfnRegister(pCallbacks, &g_DrvIfTrace);
     if (RT_FAILURE(rc))
         return rc;
+    rc = pCallbacks->pfnRegister(pCallbacks, &g_DrvSerialIce);
+    if (RT_FAILURE(rc))
+        return rc;
 
     return VINF_SUCCESS;
 }
Index: src/VBox/Devices/build/VBoxDD.h
===================================================================
--- src/VBox/Devices/build/VBoxDD.h	(Revision 139592)
+++ src/VBox/Devices/build/VBoxDD.h	(Arbeitskopie)
@@ -105,6 +105,7 @@
 #ifdef VBOX_WITH_VIRTUALKD
 extern const PDMDEVREG g_DeviceVirtualKD;
 #endif
+extern const PDMDEVREG g_DeviceIce;
 
 extern const PDMDRVREG g_DrvMouseQueue;
 extern const PDMDRVREG g_DrvKeyboardQueue;
@@ -192,6 +193,7 @@
 #endif
 
 extern const PDMDRVREG g_DrvIfTrace;
+extern const PDMDRVREG g_DrvSerialIce;
 
 /* VBoxAcpi.cpp */
 int acpiPrepareDsdt(PPDMDEVINS pDevIns, void **ppvPtr, size_t *pcbDsdt);
Index: src/VBox/Devices/Makefile.kmk
===================================================================
--- src/VBox/Devices/Makefile.kmk	(Revision 139592)
+++ src/VBox/Devices/Makefile.kmk	(Arbeitskopie)
@@ -183,6 +183,7 @@
 	\
  	Input/DrvKeyboardQueue.cpp \
  	Input/DrvMouseQueue.cpp \
+ 	Misc/DevIce.cpp \
  	Network/DrvIntNet.cpp \
  	Network/DrvDedicatedNic.cpp \
  	PC/DrvACPI.cpp \
@@ -202,7 +203,8 @@
  	Network/DrvNetSniffer.cpp \
  	Network/Pcap.cpp \
  	Trace/DrvIfsTrace.cpp \
- 	Trace/DrvIfsTrace-serial.cpp
+ 	Trace/DrvIfsTrace-serial.cpp \
+ 	Misc/DrvSerialIce.cpp
  ifn1of ($(KBUILD_TARGET), os2)
   VBoxDD_SOURCES += Storage/DrvHostBase.cpp
  endif
Index: src/VBox/VMM/VMMR3/CPUMR3Db.cpp
===================================================================
--- src/VBox/VMM/VMMR3/CPUMR3Db.cpp	(Revision 139592)
+++ src/VBox/VMM/VMMR3/CPUMR3Db.cpp	(Arbeitskopie)
@@ -1097,6 +1097,29 @@
 
 
 /**
+ * Sets handlers to intercept MSR reads and writes made from the guest (R3 only).
+ *
+ * @returns VBox status code.
+ * @param   pVM                 The cross context VM structure.
+ * @param   pfnMsrRead          The MSR read callback.
+ * @param   pfnMsrWrite         The MSR write callback.
+ * @param   pvUser              Opque user data to pass to the callbacks.
+ */
+VMMR3DECL(int) CPUMR3MsrRwInterceptSet(PVM pVM, PFNCPUMMSRREAD pfnMsrRead, PFNCPUMMSRWRITE pfnMsrWrite, void *pvUser)
+{
+    AssertPtrReturn(pVM, VERR_INVALID_PARAMETER);
+    AssertPtrReturn(pfnMsrRead, VERR_INVALID_PARAMETER);
+    AssertPtrReturn(pfnMsrWrite, VERR_INVALID_PARAMETER);
+
+    pVM->cpum.s.pfnMsrReadR3      = pfnMsrRead;
+    pVM->cpum.s.pfnMsrWriteR3     = pfnMsrWrite;
+    pVM->cpum.s.pvMsrRwUserR3     = pvUser;
+    pVM->cpum.s.fMsrInterceptsSet = true;
+    return VINF_SUCCESS;
+}
+
+
+/**
  * Register statistics for the MSRs.
  *
  * This must not be called before the MSRs have been finalized and moved to the
Index: src/VBox/VMM/VMMAll/CPUMAllMsrs.cpp
===================================================================
--- src/VBox/VMM/VMMAll/CPUMAllMsrs.cpp	(Revision 139592)
+++ src/VBox/VMM/VMMAll/CPUMAllMsrs.cpp	(Arbeitskopie)
@@ -5568,11 +5568,8 @@
 
 
 /**
- * Query a guest MSR.
+ * Query a guest MSR - worker for CPUMQueryGuestMsr().
  *
- * The caller is responsible for checking privilege if the call is the result of
- * a RDMSR instruction.  We'll do the rest.
- *
  * @retval  VINF_SUCCESS on success.
  * @retval  VINF_CPUM_R3_MSR_READ if the MSR read could not be serviced in the
  *          current context (raw-mode or ring-0).
@@ -5581,11 +5578,8 @@
  * @param   pVCpu               The cross context virtual CPU structure.
  * @param   idMsr               The MSR.
  * @param   puValue             Where to return the value.
- *
- * @remarks This will always return the right values, even when we're in the
- *          recompiler.
  */
-VMMDECL(VBOXSTRICTRC) CPUMQueryGuestMsr(PVMCPUCC pVCpu, uint32_t idMsr, uint64_t *puValue)
+static VBOXSTRICTRC cpumQueryGuestMsrWorker(PVMCPUCC pVCpu, uint32_t idMsr, uint64_t *puValue)
 {
     *puValue = 0;
 
@@ -5636,11 +5630,8 @@
 
 
 /**
- * Writes to a guest MSR.
+ * Writes to a guest MSR - worker for CPUMSetGuestMsr().
  *
- * The caller is responsible for checking privilege if the call is the result of
- * a WRMSR instruction.  We'll do the rest.
- *
  * @retval  VINF_SUCCESS on success.
  * @retval  VINF_CPUM_R3_MSR_WRITE if the MSR write could not be serviced in the
  *          current context (raw-mode or ring-0).
@@ -5650,16 +5641,8 @@
  * @param   pVCpu       The cross context virtual CPU structure.
  * @param   idMsr       The MSR id.
  * @param   uValue      The value to set.
- *
- * @remarks Everyone changing MSR values, including the recompiler, shall do it
- *          by calling this method.  This makes sure we have current values and
- *          that we trigger all the right actions when something changes.
- *
- *          For performance reasons, this actually isn't entirely true for some
- *          MSRs when in HM mode.  The code here and in HM must be aware of
- *          this.
  */
-VMMDECL(VBOXSTRICTRC) CPUMSetGuestMsr(PVMCPUCC pVCpu, uint32_t idMsr, uint64_t uValue)
+static VBOXSTRICTRC cpumSetGuestMsrWorker(PVMCPUCC pVCpu, uint32_t idMsr, uint64_t uValue)
 {
     VBOXSTRICTRC    rcStrict;
     PVM             pVM    = pVCpu->CTX_SUFF(pVM);
@@ -5726,6 +5709,88 @@
 }
 
 
+/**
+ * Query a guest MSR.
+ *
+ * The caller is responsible for checking privilege if the call is the result of
+ * a RDMSR instruction.  We'll do the rest.
+ *
+ * @retval  VINF_SUCCESS on success.
+ * @retval  VINF_CPUM_R3_MSR_READ if the MSR read could not be serviced in the
+ *          current context (raw-mode or ring-0).
+ * @retval  VERR_CPUM_RAISE_GP_0 on failure (invalid MSR), the caller is
+ *          expected to take the appropriate actions. @a *puValue is set to 0.
+ * @param   pVCpu               The cross context virtual CPU structure.
+ * @param   idMsr               The MSR.
+ * @param   puValue             Where to return the value.
+ *
+ * @remarks This will always return the right values, even when we're in the
+ *          recompiler.
+ */
+VMMDECL(VBOXSTRICTRC) CPUMQueryGuestMsr(PVMCPUCC pVCpu, uint32_t idMsr, uint64_t *puValue)
+{
+    PVM pVM = pVCpu->CTX_SUFF(pVM);
+
+    if (!pVM->cpum.s.fMsrInterceptsSet)
+        return cpumQueryGuestMsrWorker(pVCpu, idMsr, puValue);
+
+#ifndef IN_RING3
+    return VINF_CPUM_R3_MSR_READ;
+#else
+    *puValue = 0;
+
+    VBOXSTRICTRC rcStrict = pVM->cpum.s.pfnMsrReadR3(pVM, idMsr, puValue, pVM->cpum.s.pvMsrRwUserR3);
+    if (rcStrict == VINF_CPUM_MSR_READ_DO_DEFAULT)
+        rcStrict = cpumQueryGuestMsrWorker(pVCpu, idMsr, puValue);
+
+    return rcStrict;
+#endif
+}
+
+
+/**
+ * Writes to a guest MSR.
+ *
+ * The caller is responsible for checking privilege if the call is the result of
+ * a WRMSR instruction.  We'll do the rest.
+ *
+ * @retval  VINF_SUCCESS on success.
+ * @retval  VINF_CPUM_R3_MSR_WRITE if the MSR write could not be serviced in the
+ *          current context (raw-mode or ring-0).
+ * @retval  VERR_CPUM_RAISE_GP_0 on failure, the caller is expected to take the
+ *          appropriate actions.
+ *
+ * @param   pVCpu       The cross context virtual CPU structure.
+ * @param   idMsr       The MSR id.
+ * @param   uValue      The value to set.
+ *
+ * @remarks Everyone changing MSR values, including the recompiler, shall do it
+ *          by calling this method.  This makes sure we have current values and
+ *          that we trigger all the right actions when something changes.
+ *
+ *          For performance reasons, this actually isn't entirely true for some
+ *          MSRs when in HM mode.  The code here and in HM must be aware of
+ *          this.
+ */
+VMMDECL(VBOXSTRICTRC) CPUMSetGuestMsr(PVMCPUCC pVCpu, uint32_t idMsr, uint64_t uValue)
+{
+    PVM pVM = pVCpu->CTX_SUFF(pVM);
+
+    if (!pVM->cpum.s.fMsrInterceptsSet)
+        return cpumSetGuestMsrWorker(pVCpu, idMsr, uValue);
+
+#ifndef IN_RING3
+    return VINF_CPUM_R3_MSR_WRITE;
+#else
+    VBOXSTRICTRC rcStrict = pVM->cpum.s.pfnMsrWriteR3(pVM, idMsr, uValue, pVM->cpum.s.pvMsrRwUserR3);
+    if (rcStrict == VINF_CPUM_MSR_WRITE_DO_DEFAULT)
+        rcStrict = cpumSetGuestMsrWorker(pVCpu, idMsr, uValue);
+
+    return rcStrict;
+#endif
+}
+
+
 #if defined(VBOX_STRICT) && defined(IN_RING3)
 /**
  * Performs some checks on the static data related to MSRs.
Index: src/VBox/VMM/include/CPUMInternal.h
===================================================================
--- src/VBox/VMM/include/CPUMInternal.h	(Revision 139592)
+++ src/VBox/VMM/include/CPUMInternal.h	(Arbeitskopie)
@@ -365,7 +365,9 @@
     uint32_t                fHostMxCsrMask;
     /** Nested VMX: Whether to expose VMX-preemption timer to the guest. */
     bool                    fNestedVmxPreemptTimer;
-    uint8_t                 abPadding1[3];
+    /** Flag whether the MSR intercepts are set and all MSR accesses should be deferred to it. */
+    bool                    fMsrInterceptsSet;
+    uint8_t                 abPadding1[2];
 
     /** Align to 64-byte boundary. */
     uint8_t                 abPadding2[20+4];
@@ -396,6 +398,16 @@
     STAMCOUNTER             cMsrReadsRaiseGp;
     STAMCOUNTER             cMsrReadsUnknown;
     /** @} */
+
+    /** @name MSR intercepts.
+     * @{ */
+    /* MSR read intercept callback. */
+    R3PTRTYPE(PFNCPUMMSRREAD)  pfnMsrReadR3;
+    /* MSR write intercept callback. */
+    R3PTRTYPE(PFNCPUMMSRWRITE) pfnMsrWriteR3;
+    /** Opaque user data to pass to the intercept callbacks. */
+    R3PTRTYPE(void *)          pvMsrRwUserR3;
+    /** @} */
 } CPUM;
 #ifndef VBOX_FOR_DTRACE_LIB
 AssertCompileMemberOffset(CPUM, HostFeatures, 64);
